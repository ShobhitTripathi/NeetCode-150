# [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/)
Medium


In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

 

Example 1:
```
Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
```
Example 2:
```
Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]
 ```

Constraints:

- n == edges.length
- 3 <= n <= 1000
- edges[i].length == 2
- 1 <= ai < bi <= edges.length
- ai != bi
- There are no repeated edges.
- The given graph is connected.

## Approach
Approach Using Union-Find (DSU):

Initialize:
parent[]: tracks each node’s parent (initially itself).
rank[] or size[]: helps optimize merges (keep trees shallow).
Process each edge [u, v]:
Use find(u) and find(v) to check if u and v are in the same set.
If same parent → edge forms a cycle → return this edge.
If different → union(u, v) → merge the two sets.
Use path compression in find() to flatten the tree.
Use union by rank/size to keep the trees balanced.

Why It Works:
A cycle is formed only when two nodes already belong to the same set.

```
## Solution
```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int[] par = new int[edges.length + 1];  // Parent array to track connected components
        int[] rank = new int[edges.length + 1]; // Rank (or size) array to optimize union by size

        // Initialize each node's parent to itself and rank to 1
        for (int i = 0; i < par.length; i++) {
            par[i] = i;
            rank[i] = 1;
        }

        // Process each edge
        for (int[] edge : edges) {
            // If u and v are already connected, this edge is redundant
            if (!union(par, rank, edge[0], edge[1])) {
                return new int[]{edge[0], edge[1]};
            }
        }

        return new int[]{}; // Should not happen per problem constraints
    }

    // FIND with path compression
    private int find(int[] par, int n) {
        int p = par[n];

        // Climb up the parent chain and compress the path
        while (p != par[p]) {
            par[p] = par[par[p]]; // Path compression: point to grandparent
            p = par[p];
        }

        return p;
    }

    // UNION by rank (size)
    private boolean union(int[] par, int[] rank, int n1, int n2) {
        int p1 = find(par, n1);
        int p2 = find(par, n2);

        // Same root → adding this edge creates a cycle
        if (p1 == p2) {
            return false;
        }

        // Attach smaller tree under larger one (by rank)
        if (rank[p1] > rank[p2]) {
            par[p2] = p1;
            rank[p1] += rank[p2];  // Update size
        } else {
            par[p1] = p2;
            rank[p2] += rank[p1];
        }

        return true; // Union successful
    }
}

```

## Complexity Analysis
```
- Time Complexity: O(n)
- Space Complexity: O(n)
```


```java
// DFS solution [not optimal]
// Time complexity: O(E∗(V+E))
// Space complexity: O(V+E)

class Solution {
    Map<Integer, List<Integer>> graph;
    List<int[]> result;
    // Set<Integer> visited;

    public int[] findRedundantConnection(int[][] edges) {
        graph = new HashMap<>();
        result = new ArrayList<>();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(v);
            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(u);
            Set<Integer> visited = new HashSet<>();

            if (dfs(u, -1, visited)) {
                return edge;
            }


        }
        
        return new int[]{};   
    }

    private boolean dfs(int node, int parent, Set<Integer> visited) {
        if (visited.contains(node)) {
            return true;
        }
        visited.add(node);

        for (int nei : graph.getOrDefault(node, Collections.emptyList())) {
            if (nei == parent) {
                continue;
            }
            if (dfs(nei, node, visited)) {
                return true;
            }
        }

        return false;
    }
}

```
