# [178 · Graph Valid Tree](https://www.lintcode.com/problem/178/)
Medium

Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.


Example 1:
```
Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]]
Output: true.
```
Example 2:
```
Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]
Output: false.
```

## Approach
```
- Cycle Detection: If a node is visited more than once during DFS, a cycle exists.
- Connectivity Check: All nodes must be reachable from the starting node.
- Edge Count Validation: A valid tree must have exactly n−1 edges.


// 2
- check if number of edges is equal to n-1 or not
  - if not equal return false;
- do dfs and put it in a set, size of set should be equal to number of nodes
```

## Solution
```java

class Solution {
    // Adjacency list representation of the graph
    Map<Integer, List<Integer>> graph;

    // Set to keep track of visited nodes during DFS
    Set<Integer> visited;

    public boolean validTree(int n, int[][] edges) {
        graph = new HashMap<>();
        visited = new HashSet<>();

        // Build the undirected graph from the edge list
        for (int[] edge : edges) {
            graph.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(edge[1]);
            graph.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(edge[0]);
        }

        // Start DFS traversal from node 0 with parent = -1 (no parent)
        // If cycle is detected, return false
        if (!dfs(0, -1)) {
            return false;
        }

        // Check if all nodes are visited => graph is fully connected
        return visited.size() == n;
    }

    // DFS to check for cycles
    private boolean dfs(int node, int parent) {
        // If the node has already been visited, a cycle is detected
        if (visited.contains(node)) {
            return false;
        }

        // Mark the node as visited
        visited.add(node);

        // Explore all neighbors of the current node
        for (int nei : graph.getOrDefault(node, Collections.emptyList())) {
            // Skip the parent node to avoid trivial cycle
            if (nei == parent) {
                continue;
            }

            // If DFS from neighbor detects a cycle, return false
            if (!dfs(nei, node)) {
                return false;
            }
        }

        // No cycle found from this path
        return true;
    }
}


```

## Complexity Analysis
```
- Time Complexity: O(n*m)
- Space Complexity: O(n+m)
```
