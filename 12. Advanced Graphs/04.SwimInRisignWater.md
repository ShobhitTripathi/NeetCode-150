# Swim in Rising Water

You are given a square 2-D matrix of distinct integers grid where each integer grid[i][j] represents the elevation at position (i, j).
Rain starts to fall at time = 0, which causes the water level to rise. At time t, the water level across the entire grid is t.
You may swim either horizontally or vertically in the grid between two adjacent squares if the original elevation of both squares is less than or equal to the water level at time t.
Starting from the top left square (0, 0), return the minimum amount of time it will take until it is possible to reach the bottom right square (n - 1, n - 1).

Example 1:
```
Input: grid = [[0,1],[2,3]]
Output: 3
Explanation: For a path to exist to the bottom right square grid[1][1] the water elevation must be at least 3. At time t = 3, the water level is 3.
```
Example 2:
```
Input: grid = [
  [0,1,2,10],
  [9,14,4,13],
  [12,3,8,15],
  [11,5,7,6]]
]
Output: 8
Explanation: The water level must be at least 8 to reach the bottom right square. The path is [0, 1, 2, 4, 8, 7, 6].
```
Constraints:
```
grid.length == grid[i].length
1 <= grid.length <= 50
0 <= grid[i][j] < n^2
```
Approach
```
Use Dijkstra on the grid where the cost of a path is the maximum height encountered;
always expand the cell with the minimum such cost.

Time : O(N² log N)
Each of the N² cells is pushed into the heap
Heap operations cost log(N²)
```

Solution
```java

class Solution {
    private int ROWS;
    private int COLS;

    // 4-directional movement (right, left, down, up)
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int swimInWater(int[][] grid) {
        ROWS = grid.length;
        COLS = grid[0].length;

        // Min-heap: [maxTimeSoFar, row, col]
        // Always expand the cell with the minimum required time first
        PriorityQueue<int[]> pq =
                new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));

        // Visited array to finalize cells once their minimum time is fixed
        boolean[][] visited = new boolean[ROWS][COLS];

        // Start from (0,0); initial time is grid[0][0]
        pq.offer(new int[]{grid[0][0], 0, 0});

        while (!pq.isEmpty()) {
            int[] node = pq.poll();
            int time = node[0];
            int r = node[1];
            int c = node[2];

            // Skip if this cell was already finalized
            if (visited[r][c]) continue;
            visited[r][c] = true;

            // Destination reached with minimum possible time
            if (r == ROWS - 1 && c == COLS - 1) {
                return time;
            }

            // Explore all 4 neighboring cells
            for (int[] dir : directions) {
                int nr = r + dir[0];
                int nc = c + dir[1];

                // Valid and not yet finalized
                if (isValidCell(nr, nc) && !visited[nr][nc]) {
                    // Time to move is max of current path time and neighbor height
                    pq.offer(new int[]{
                            Math.max(time, grid[nr][nc]),
                            nr,
                            nc
                    });
                }
            }
        }

        return -1; // Should not happen for valid input
    }

    // Check grid boundaries
    private boolean isValidCell(int r, int c) {
        return r >= 0 && r < ROWS && c >= 0 && c < COLS;
    }
}


```
