Detect Squares

You are given a stream of points consisting of x-y coordinates on a 2-D plane. Points can be added and queried as follows:

Add - new points can be added to the stream into a data structure. Duplicate points are allowed and should be treated as separate points.
Query - Given a single query point, count the number of ways to choose three additional points from the data structure such that the three points and the query point form a square. The square must have all sides parallel to the x-axis and y-axis, i.e. no diagonal squares are allowed. Recall that a square must have four equal sides.
Implement the CountSquares class:

CountSquares() Initializes the object.
void add(int[] point) Adds a new point point = [x, y].
int count(int[] point) Counts the number of ways to form valid squares with point point = [x, y] as described above.

Example 1:
```
Input: 
["CountSquares", "add", [[1, 1]], "add", [[2, 2]], "add", [[1, 2]], "count", [[2, 1]], "count", [[3, 3]], "add", [[2, 2]], "count", [[2, 1]]]
       
Output:
[null, null, null, null, 1, 0, null, 2]

Explanation:
CountSquares countSquares = new CountSquares();
countSquares.add([1, 1]);
countSquares.add([2, 2]);
countSquares.add([1, 2]);

countSquares.count([2, 1]);   // return 1.
countSquares.count([3, 3]);   // return 0.
countSquares.add([2, 2]);     // Duplicate points are allowed.
countSquares.count([2, 1]);   // return 2.
```

Constraints:
```
point.length == 2
0 <= x, y <= 1000
```


Solution
```java

public class CountSquares {

    // Stores frequency of each point: (x,y) -> count
    // We use this because the input can have duplicate points.
    private Map<List<Integer>, Integer> ptsCount;

    // Stores all points added so far (including duplicates)
    private List<List<Integer>> pts;

    public CountSquares() {
        ptsCount = new HashMap<>();
        pts = new ArrayList<>();
    }

    // Adds a point to the data structure
    public void add(int[] point) {
        List<Integer> p = Arrays.asList(point[0], point[1]);

        // Count how many times this point appears
        ptsCount.put(p, ptsCount.getOrDefault(p, 0) + 1);

        // Add point to list (needed to iterate all points in count())
        pts.add(p);
    }

    // Count how many axis-aligned squares can be formed with 'point' as one of the vertices
    public int count(int[] point) {
        int res = 0;
        int px = point[0], py = point[1];

        // Iterate over every previously added point
        for (List<Integer> pt : pts) {
            int x = pt.get(0), y = pt.get(1);

            // We are looking for diagonal points of the square.
            // For a square:
            // |px - x| == |py - y|  AND  x != px  AND  y != py
            // This means (x,y) is a diagonal relative to (px,py)
            if (Math.abs(py - y) != Math.abs(px - x) || x == px || y == py) {
                continue;
            }

            // Now (x,y) is a diagonal. For a square, the remaining two points must be:
            // (x, py) and (px, y)

            // Multiply the counts because duplicates must be considered.
            res += ptsCount.getOrDefault(Arrays.asList(x, py), 0) *
                   ptsCount.getOrDefault(Arrays.asList(px, y), 0);
        }
        return res;
    }
}

```

Complexity
```
Time complexity: 
O(1) for add(), 
O(n) for count().

Space complexity: O(n)
```
