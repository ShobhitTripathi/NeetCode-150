# [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)

Given an integer array nums, return the length of the longest strictly increasing subsequence.

A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].

 Example 1:
```
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```
Example 2:
```
Input: nums = [0,1,0,3,2,3]
Output: 4
```
Example 3:
```
Input: nums = [7,7,7,7,7,7,7]
Output: 1
``` 

Constraints:
```
- 1 <= nums.length <= 2500
- -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>
 ```

> Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?

## Approach
```
Intution-:
For each element, you explore all future elements to extend the subsequence, and the final max gives the answer.

Algo-:
Use a DP array LIS[]:
LIS[i] stores the length of the longest increasing subsequence starting from index i.

Initialize:
Every element alone is a subsequence of length 1 â†’ LIS[i] = 1.

Iterate from right to left:
For each index i, check all elements j > i.

If nums[i] < nums[j], it means we can extend the subsequence from i to j.

Update LIS[i] = max(LIS[i], 1 + LIS[j]).

Answer:
The final result is the maximum value in the LIS array.
```

## Solution
```java
import java.util.Arrays;

class Solution {
    public int lengthOfLIS(int[] nums) {
        // DP array where LIS[i] = length of longest increasing subsequence starting at index i
        int[] LIS = new int[nums.length];
        
        // Every element itself forms a subsequence of length 1
        Arrays.fill(LIS, 1);

        // Traverse from right to left (bottom-up approach)
        for (int i = nums.length - 1; i >= 0; i--) {
            // For each element, check all elements to its right
            for (int j = i + 1; j < nums.length; j++) {
                // If nums[i] < nums[j], then nums[j] can be part of LIS starting at i
                if (nums[i] < nums[j]) {
                    // Update LIS[i] as the best possible subsequence length
                    LIS[i] = Math.max(LIS[i], 1 + LIS[j]);
                }
            }
        }

        // The length of the overall LIS will be the maximum value in the LIS array
        return Arrays.stream(LIS).max().getAsInt();
    }
}


```
## Complexity Analysis
```
- Time Complexity: O(n^2)
- Space Complexity: O(n)
```
