# 5. Longest Palindromic Substring
Medium


Given a string s, return the longest palindromic substring in s.

 
Example 1:
```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```
Example 2:
```
Input: s = "cbbd"
Output: "bb"
``` 

Constraints:

- 1 <= s.length <= 1000
- s consist of only digits and English letters.

## Approach
```
Approach 1:
  - for each index, try to find odd length & even length palindromes
  - odd: start the inner loop from the same index
  - even: start the inner loop one pointer on i and other at i+1
  - expand towards the left and right of i while the chars are same
  - keep checking the len, and store the start and end
  - substring(start,end+1), end+1 because the substring method takes end index one more than the original end index
  
Approach 2:
- Manacher Algorithm
```
![image](https://user-images.githubusercontent.com/20329508/167583252-2ec3eaf2-24a3-4d26-aa4f-9e315cc8b635.png)

## Solution
```java
class Solution {
    public String longestPalindrome(String s) {
        int resLen = 0, resIdx = 0;

        if(s == null || s.length() == 0)
            return "";

        for (int i = 0;i < s.length();i++) {
            // odd length
            int l = i, r = i;
            while (l >= 0 && r < s.length() &&
                    s.charAt(l) == s.charAt(r)) {
                        if (r - l + 1 > resLen) {
                            resIdx = l;
                            resLen = r - l + 1;
                        }
                l--;
                r++;
            }

            // even length
            l = i;
            r = i + 1;
            while (l >= 0 && r < s.length() &&
                s.charAt(l) == s.charAt(r)) {
                if (r - l + 1 > resLen) {
                    resIdx = l;
                    resLen = r - l + 1;
                }
                l--;
                r++;
            }
        }
        return s.substring(resIdx, resIdx + resLen);
    }
}
```

Approach2
```java
public class Solution {
    public int[] manacher(String s) {
        StringBuilder t = new StringBuilder("#");
        for (char c : s.toCharArray()) {
            t.append(c).append("#");
        }
        int n = t.length();
        int[] p = new int[n];
        int l = 0, r = 0;
        for (int i = 0; i < n; i++) {
            p[i] = (i < r) ? Math.min(r - i, p[l + (r - i)]) : 0;
            while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 &&
                   t.charAt(i + p[i] + 1) == t.charAt(i - p[i] - 1)) {
                p[i]++;
            }
            if (i + p[i] > r) {
                l = i - p[i];
                r = i + p[i];
            }
        }
        return p;
    }

    public String longestPalindrome(String s) {
        int[] p = manacher(s);
        int resLen = 0, center_idx = 0;
        for (int i = 0; i < p.length; i++) {
            if (p[i] > resLen) {
                resLen = p[i];
                center_idx = i;
            }
        }
        int resIdx = (center_idx - resLen) / 2;
        return s.substring(resIdx, resIdx + resLen);
    }
}
```

## Complexity Analysis
```
- Time Complexity:
  - Approach 1: O(N*N)
  - Approach 2: O(N)
- Space Complexity:
  - Approach 1: O(1)
  - Approach 2: O(N)
```
