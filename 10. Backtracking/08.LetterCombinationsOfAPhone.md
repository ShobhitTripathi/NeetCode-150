# [17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)
Medium


Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.



 

Example 1:
```
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
```
Example 2:
```
Input: digits = ""
Output: []
```
Example 3:
```
Input: digits = "2"
Output: ["a","b","c"]
 ```

Constraints:

- 0 <= digits.length <= 4
- digits[i] is a digit in the range ['2', '9'].

## Approach
```
Backtrack:
char chs[] = mp.get(str.charAt(i));
for(int j = 0; j < chs.length; j++) {
    recursive(str, i+1, s+chs[j], res); - stmt
}
stmt is equivalent to:
String s = s+chs[j];
recursive(str, i+1, s, res);
s = s.substring(0,s.length()-1);
```

## Solution
```java
class Solution {
    // To store the final combinations
    List<String> result;

    // Mapping of digits to corresponding letters (like on a phone keypad)
    String[] mapping = {
        "",     // 0
        "",     // 1
        "abc",  // 2
        "def",  // 3
        "ghi",  // 4
        "jkl",  // 5
        "mno",  // 6
        "pqrs", // 7
        "tuv",  // 8
        "wxyz"  // 9
    };

    public List<String> letterCombinations(String digits) {
        result = new ArrayList<>();

        // If input is empty, return empty list
        if (digits.isEmpty()) {
            return result;
        }

        // Start backtracking from index 0 with an empty current combination
        backtrack(0, "", digits);
        return result;
    }

    // Recursive helper function for backtracking
    private void backtrack(int i, String curr, String digits) {
        // Base case: if current combination length equals digits length, add to result
        if (curr.length() == digits.length()) {
            result.add(curr);
            return;
        }

        // Get the letters mapped to the current digit
        String chars = mapping[digits.charAt(i) - '0'];

        // Explore all possible letters for the current digit
        for (char ch : chars.toCharArray()) {
            // Move to the next digit, appending the current letter to the combination
            backtrack(i + 1, curr + ch, digits);
        }
    }
}

```

## Complexity Analysis
```
- Time Complexity: (4^n * n) where n = length of the input digits string
- Space Complexity: (4^n * n)
```
