Regular Expression Matching
 
You are given an input string s consisting of lowercase english letters, and a pattern p consisting of lowercase english letters, as well as '.', and '*' characters.

Return true if the pattern matches the entire input string, otherwise return false.

'.' Matches any single character
'*' Matches zero or more of the preceding element.
Example 1:
```
Input: s = "aa", p = ".b"

Output: false
Explanation: Regardless of which character we choose for the '.' in the pattern, we cannot match the second character in the input string.
```

Example 2:
```
Input: s = "nnn", p = "n*"

Output: true
Explanation: '*' means zero or more of the preceding element, 'n'. We choose 'n' to repeat three times.
```
Example 3:
```
Input: s = "xyz", p = ".*z"

Output: true
Explanation: The pattern ".*" means zero or more of any character, so we choose ".." to match "xy" and "z" to match "z".
```
Constraints:
```
1 <= s.length <= 20
1 <= p.length <= 20
Each appearance of '*', will be preceded by a valid character or '.'.
```

Approach
```
“We recursively match the string and pattern, handling * as zero-or-more occurrences,
and memoize states to avoid exponential branching.”

Core Intuition:
At each (i, j) position:
We try to match s[i] with p[j]
If the next pattern character is '*', we have branching choices
Memoization avoids exponential recomputation
```

Solution
```java
// O(m * n)
class Solution {

    // dp[i][j] = whether s[i:] matches p[j:]
    private Boolean[][] dp;

    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();

        // Memo table: null = uncomputed, true/false = computed result
        dp = new Boolean[m + 1][n + 1];

        // Start matching from index 0 of both strings
        return dfs(0, 0, s, p, m, n); 
    }

    private boolean dfs(int i, int j, String s, String p, int m, int n) {

        // If pattern is fully consumed,
        // string must also be fully consumed
        if (j == n) {
            return i == m;
        }

        // Return cached result if already computed
        if (dp[i][j] != null) {
            return dp[i][j];
        }

        // Check if current characters match
        // '.' matches any single character
        boolean match = i < m &&
                        (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');

        // Case 1: Next character in pattern is '*'
        if (j + 1 < n && p.charAt(j + 1) == '*') {

            // Two choices:
            // 1. Skip the "x*" pattern (match zero occurrences)
            // 2. Use one occurrence of x (if current chars match)
            dp[i][j] =
                dfs(i, j + 2, s, p, m, n) ||
                (match && dfs(i + 1, j, s, p, m, n));

        } else {
            // Case 2: Normal character or '.'
            dp[i][j] = match && dfs(i + 1, j + 1, s, p, m, n);
        }

        return dp[i][j];
    }
}


```
