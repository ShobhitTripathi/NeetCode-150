# Target Sum
 
You are given an array of integers nums and an integer target.

For each number in the array, you can choose to either add or subtract it to a total sum.

For example, if nums = [1, 2], one possible sum would be "+1-2=-1".
If nums=[1,1], there are two different ways to sum the input numbers to get a sum of 0: "+1-1" and "-1+1".

Return the number of different ways that you can build the expression such that the total sum equals target.

Example 1:
```
Input: nums = [2,2,2], target = 2

Output: 3
Explanation: There are 3 different ways to sum the input numbers to get a sum of 2.
+2 +2 -2 = 2
+2 -2 +2 = 2
-2 +2 +2 = 2
```
Constraints:
```
1 <= nums.length <= 20
0 <= nums[i] <= 1000
-1000 <= target <= 1000
```

Approach
```
 Key Idea
Use DFS with memoization where each index chooses +nums[i] or -nums[i], and store results keyed by (i, total) to avoid recomputation.

Time Complexity
O(n × totalSum × 2) ≈ O(n × totalSum) — each (i, shiftedTotal) state computed once.

Space Complexity
O(n × totalSum) for memo + recursion depth O(n).
```

Solution
```java

class Solution {
    private int[][] dp;
    private int totalSum;

    public int findTargetSumWays(int[] nums, int target) {
        totalSum = Arrays.stream(nums).sum();
        dp = new int[nums.length][2 * totalSum + 1];

        for (int i = 0;i < nums.length;i++) {
            for (int j = 0;j < 2 * totalSum + 1;j++) {
                dp[i][j] = Integer.MIN_VALUE;
            }
        }

        return backtrack(0, 0, nums, target);    
    }

    private int backtrack(int i, int total, int[] nums, int target) {
        if (i == nums.length) {
            return total == target ? 1 : 0;
        }
        if (dp[i][total + totalSum] != Integer.MIN_VALUE) {
            return dp[i][total + totalSum];
        }

        dp[i][total + totalSum] = backtrack(i + 1, total + nums[i], nums, target) +
                                  backtrack(i + 1, total - nums[i], nums, target);

        return dp[i][total + totalSum];
    }
}


```
