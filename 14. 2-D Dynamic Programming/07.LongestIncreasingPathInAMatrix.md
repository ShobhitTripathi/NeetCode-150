# [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)
Hard


Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).

 

Example 1:
```
Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
Output: 4
Explanation: The longest increasing path is [1, 2, 6, 9].
```
Example 2:
```
Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
Output: 4
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.
```
Example 3:
```
Input: matrix = [[1]]
Output: 1
 ```

Constraints:

- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 200
- 0 <= matrix[i][j] <= 2<sup>31</sup> - 1

## Approach
```
Treat each cell as a node in a DAG where edges go from smaller → larger values;
the longest increasing path equals the number of BFS layers in topological order.
```

## Algorithm
```
Treat each cell (r, c) as a node.

Compute indegree[r][c]:
 indegree[r][c] = number of neighboring cells with a smaller value (neighbors that point into (r, c))

For each cell, look at its 4 neighbors:
 if a neighbor value is smaller, increase the cell’s indegree

Initialize a queue with all cells that have indegree 0:
 these are local minima and can start an increasing path

Perform BFS in layers:
 for each layer:
  pop all current nodes in the queue
  for each popped cell, check its 4 neighbors
  if a neighbor has a larger value, it is reachable from the current cell:
    decrement that neighbor’s indegree
    if the neighbor’s indegree becomes 0, push it into the queue

  after finishing the layer, increment the answer (LIS += 1)

When the queue becomes empty, all nodes have been processed.

Return the number of layers processed (LIS), which equals the longest increasing path length.
```

## Solution
```java
class Solution {

    // Matrix dimensions
    private int ROWS;
    private int COLS;

    // 4-directional movement: right, down, left, up
    private int[][] directions = {
        {0, 1}, {1, 0}, {0, -1}, {-1, 0}
    };

    public int longestIncreasingPath(int[][] matrix) {

        ROWS = matrix.length;
        COLS = matrix[0].length;

        // indegree[r][c] = number of neighbors with smaller value than matrix[r][c]
        int[][] indegree = new int[ROWS][COLS];

        // Step 1: Build indegree graph
        // If neighbor value < current value, then an edge exists:
        // neighbor -> current
        for (int r = 0; r < ROWS; r++) {
            for (int c = 0; c < COLS; c++) {
                for (int[] dir : directions) {
                    int nr = r + dir[0];
                    int nc = c + dir[1];

                    // Check bounds and increasing condition
                    if (nr >= 0 && nc >= 0 && nr < ROWS && nc < COLS &&
                        matrix[nr][nc] < matrix[r][c]) {
                        indegree[r][c]++;
                    }
                }
            }
        }

        // Step 2: Push all nodes with indegree 0 into queue
        // These are local minima (start of increasing paths)
        Queue<int[]> q = new LinkedList<>();
        for (int r = 0; r < ROWS; r++) {
            for (int c = 0; c < COLS; c++) {
                if (indegree[r][c] == 0) {
                    q.offer(new int[]{r, c});
                }
            }
        }

        // Step 3: BFS level by level (Topological Sort)
        // Each BFS layer corresponds to one length increment
        int LIS = 0;

        while (!q.isEmpty()) {
            int size = q.size();

            // Process one layer
            for (int i = 0; i < size; i++) {
                int[] node = q.poll();
                int r = node[0];
                int c = node[1];

                // Visit all neighbors with larger values
                for (int[] dir : directions) {
                    int nr = r + dir[0];
                    int nc = c + dir[1];

                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS &&
                        matrix[nr][nc] > matrix[r][c]) {

                        // Reduce indegree as one dependency is resolved
                        if (--indegree[nr][nc] == 0) {
                            q.offer(new int[]{nr, nc});
                        }
                    }
                }
            }

            // Completed one increasing level
            LIS++;
        }

        return LIS;
    }
}

```

## Complexity Analysis
```
- Time Complexity: O(n*m)
- Space Complexity: O(n*m) 
```
