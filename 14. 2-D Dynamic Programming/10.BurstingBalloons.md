# Burst Balloons

You are given an array of integers nums of size n. The ith element represents a balloon with an integer value of nums[i]. You must burst all of the balloons.

If you burst the ith balloon, you will receive nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then assume the out of bounds value is 1.

Return the maximum number of coins you can receive by bursting all of the balloons.

Example 1:
```
Input: nums = [4,2,3,7]
Output: 143
Explanation:
nums = [4,2,3,7] --> [4,3,7] --> [4,7] --> [7] --> []
coins =  4*2*3    +   4*3*7   +  1*4*7  + 1*7*1 = 143
```

Constraints:
```
n == nums.length
1 <= n <= 300
0 <= nums[i] <= 100
```

Approach
```
“We use interval DP and assume each balloon is burst last in its subarray;
this fixes its neighbors and makes the coin calculation deterministic.”

Intution-:

Instead of thinking which balloon to burst first, think:
Which balloon is burst last in a given interval.

Why this works:
  When balloon i is the last to be burst in [l, r],
  Its neighbors are fixed: nums[l-1] and nums[r+1]
  So the coins gained are deterministic:

  nums[l-1] * nums[i] * nums[r+1]
This converts the problem into interval DP.

Transition Formula:

dp[l][r] = max over i in [l, r] of:
    nums[l-1] * nums[i] * nums[r+1]
    + dp[l][i-1]
    + dp[i+1][r]
```

Solution
```java
// Time: O(n^3), Space: O(n^2) 
class Solution {

    public int maxCoins(int[] nums) {
        int n = nums.length;

        // Create a new array with padding 1 on both ends
        // This avoids boundary checks when bursting edge balloons
        int[] newNums = new int[n + 2];
        newNums[0] = 1;
        newNums[n + 1] = 1;

        // Copy original nums into the middle
        for (int i = 0; i < n; i++) {
            newNums[i + 1] = nums[i];
        }

        // dp[l][r] = maximum coins obtainable
        // by bursting balloons in interval [l, r]
        int[][] dp = new int[n + 2][n + 2];

        // Initialize dp with -1 to mark uncomputed states
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }

        // Solve for the full interval (excluding padding)
        return dfs(newNums, 1, n, dp);
    }

    private int dfs(int[] nums, int l, int r, int[][] dp) {

        // Base case: empty interval
        if (l > r) {
            return 0;
        }

        // Return memoized result
        if (dp[l][r] != -1) {
            return dp[l][r];
        }

        dp[l][r] = 0;

        // Try bursting each balloon i last in the interval [l, r]
        for (int i = l; i <= r; i++) {

            // Coins gained by bursting i last
            int coins = nums[l - 1] * nums[i] * nums[r + 1];

            // Add coins from left and right subintervals
            coins += dfs(nums, l, i - 1, dp);
            coins += dfs(nums, i + 1, r, dp);

            // Take the maximum
            dp[l][r] = Math.max(dp[l][r], coins);
        }

        return dp[l][r];
    }
}


```
