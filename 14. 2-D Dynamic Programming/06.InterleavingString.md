Interleaving String
 
You are given three strings s1, s2, and s3. Return true if s3 is formed by interleaving s1 and s2 together or false otherwise.

Interleaving two strings s and t is done by dividing s and t into n and m substrings respectively, where the following conditions are met

|n - m| <= 1, i.e. the difference between the number of substrings of s and t is at most 1.
s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
Interleaving s and t is s1 + t1 + s2 + t2 + ... or t1 + s1 + t2 + s2 + ...
You may assume that s1, s2 and s3 consist of lowercase English letters.

Example 1:
```
Input: s1 = "aaaa", s2 = "bbbb", s3 = "aabbbbaa"
Output: true
Explanation: We can split s1 into ["aa", "aa"], s2 can remain as "bbbb" and s3 is formed by interleaving ["aa", "aa"] and "bbbb".
```
Example 2:
```
Input: s1 = "", s2 = "", s3 = ""
Output: true
```
Example 3:
```
Input: s1 = "abc", s2 = "xyz", s3 = "abxzcy"
Output: false
Explanation: We can't split s3 into ["ab", "xz", "cy"] as the order of characters is not maintained.
```

Constraints:
```
0 <= s1.length, s2.length <= 100
0 <= s3.length <= 200
```

Approach
```
“We try to match s3 character by character by choosing from s1 or s2;
memoization avoids exponential branching.”

At every position in s3, you must choose exactly one character:
either from s1
or from s2
The relative order of characters in s1 and s2 must be preserved.
This leads to a binary decision tree, which we prune using memoization.

```

Solution
```java
class Solution {

    // dp[i][j] = whether s3[k:] can be formed using
    // s1[i:] and s2[j:], where k = i + j
    private Boolean[][] dp;

    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();

        // Length mismatch → impossible
        if (m + n != s3.length()) return false;

        // Memo table (Boolean used to distinguish unvisited states)
        dp = new Boolean[m + 1][n + 1];

        // Start DFS from beginning of all strings
        return dfs(0, 0, 0, s1, s2, s3);
    }

    private boolean dfs(int i, int j, int k,
                        String s1, String s2, String s3) {

        // If we've consumed all characters of s3,
        // both s1 and s2 must also be fully consumed
        if (k == s3.length()) {
            return (i == s1.length()) && (j == s2.length());
        }

        // Return memoized result if already computed
        if (dp[i][j] != null) {
            return dp[i][j];
        }

        boolean res = false;

        // Option 1: Take next character from s1 if it matches s3[k]
        if (i < s1.length() && s1.charAt(i) == s3.charAt(k)) {
            res = dfs(i + 1, j, k + 1, s1, s2, s3);
        }

        // Option 2: Take next character from s2 if it matches s3[k]
        // Only try this if Option 1 did not already succeed
        if (!res && j < s2.length() && s2.charAt(j) == s3.charAt(k)) {
            res = dfs(i, j + 1, k + 1, s1, s2, s3);
        }

        // Cache result for this state
        dp[i][j] = res;
        return res;
    }
}

```
