# [518. Coin Change 2](https://leetcode.com/problems/coin-change-2/)

You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.

You may assume that you have an infinite number of each kind of coin.

The answer is guaranteed to fit into a signed 32-bit integer.

 Example 1:
```
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
Example 2:
```
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
```
Example 3:
```
Input: amount = 10, coins = [10]
Output: 1
``` 

Constraints:
```
- 1 <= coins.length <= 300
- 1 <= coins[i] <= 5000
- All the values of coins are unique.
- 0 <= amount <= 5000
```

## Approach
```
Use DFS + memo where each state (i, a) chooses to either skip the current coin or reuse it,
and memoize to avoid recomputing overlapping subproblems.
```

## Solution
```java
public class Solution {
    public int change(int amount, int[] coins) {
        Arrays.sort(coins); // sort to ensure consistent order (optional but clean)

        // memo[i][a] = number of ways to form amount 'a' using coins[i...]
        int[][] memo = new int[coins.length + 1][amount + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }

        return dfs(0, amount, coins, memo);
    }

    private int dfs(int i, int a, int[] coins, int[][] memo) {

        // If amount becomes 0 → one valid combination found
        if (a == 0) return 1;

        // If no coins left and amount still > 0 → no valid combination
        if (i >= coins.length) return 0;

        // Return cached result
        if (memo[i][a] != -1) return memo[i][a];

        int res = 0;

        // Option 1: skip the current coin (move to next coin)
        if (a >= coins[i]) {
            res = dfs(i + 1, a, coins, memo);

            // Option 2: include current coin (stay at same index because unlimited supply)
            res += dfs(i, a - coins[i], coins, memo);
        }

        memo[i][a] = res;
        return res;
    }
}


```

## Complexity Analysis
```
Time Complexity
O(n × amount) — each (i, a) state computed once.

Space Complexity
O(n × amount) memo + recursion depth up to O(n + amount).
```
