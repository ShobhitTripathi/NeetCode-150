# Distinct Subsequences

You are given two strings s and t, both consisting of english letters.

Return the number of distinct subsequences of s which are equal to t.

Example 1:
```
Input: s = "caaat", t = "cat"
Output: 3
Explanation: There are 3 ways you can generate "cat" from s.

(c)aa(at)
(c)a(a)a(t)
(ca)aa(t)
```
Example 2:
```
Input: s = "xxyxy", t = "xy"
Output: 5
Explanation: There are 5 ways you can generate "xy" from s.

(x)x(y)xy
(x)xyx(y)
x(x)(y)xy
x(x)yx(y)
xxy(x)(y)
```
Constraints:
```
1 <= s.length, t.length <= 1000
s and t consist of English letters.
```

Approach
```
At every index i in s, you have two choices:
Skip s[i]
Try forming t[j:] from s[i+1:]
Use s[i] (only if s[i] == t[j])
Move both pointers forward
The total number of distinct subsequences is the sum of both choices.
```

Solution
```java
// O(m Ã— n)
class Solution {

    // dp[i][j] = number of distinct subsequences of s[i:]
    // that can form t[j:]
    int[][] dp;

    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();

        // If target is longer than source, impossible
        if (n > m) return 0;

        // Initialize memo table with -1 (uncomputed)
        dp = new int[m + 1][n + 1];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }

        // Start DFS from index 0 of both strings
        return dfs(s, t, 0, 0);
    }

    private int dfs(String s, String t, int i, int j) {

        // If we matched all characters of t
        // One valid subsequence is formed
        if (j == t.length()) return 1;

        // If s is exhausted but t is not
        // No subsequence possible
        if (i == s.length()) return 0;

        // Return cached result
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        // Option 1: skip current character of s
        int res = dfs(s, t, i + 1, j);

        // Option 2: match s[i] with t[j] (if equal)
        if (s.charAt(i) == t.charAt(j)) {
            res += dfs(s, t, i + 1, j + 1);
        }

        // Store result in memo table
        dp[i][j] = res;
        return res;
    }
}

```
